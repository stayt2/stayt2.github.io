# 算法分析
Python 一些常见的算法库：
1. collections - 这个模块提供了许多扩展的容器类型：

    - deque: 提供了一个双端队列，支持从前端或后端以近乎 O(1) 的复杂度添加或删除元素。
    - Counter: 用于计数可哈希对象。
    - OrderedDict: 保持键的插入顺序的字典。
    - defaultdict: 在查询不存在的键时提供一个默认值。

2. heapq - 这个模块提供了对堆队列算法的支持，特别是实现了一个优先队列算法：
    - 提供了堆的创建、插入元素、删除元素等功能。

3. itertools - 提供了许多迭代器，能够帮助创建高效的循环：

    - combinations, permutations: 生成数据的组合或排列。
    - cycle, repeat: 用于创建重复的迭代器。
    - chain: 用于合并多个迭代器。

## 递归
阶乘计算，斐波那契数列，汉诺塔问题，二叉树的遍历，数组求和，回溯算法中的递归：解决诸如八皇后问题、迷宫问题等需要回溯的问题。通过递归尝试每一种可能的解决方案，并在不符合条件时回溯。

## 贪心
贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最佳或最优的算法策略。贪心算法不总是得到全局最优解，但在很多问题中可以得到局部最优解，有时候这已足够接近全局最优了。以下列举一些常见的贪心算法的应用场景：

1. **活动选择问题**
   - 描述：给定一组活动，每个活动都有一个开始时间和结束时间。选择最大数量的互不重叠的活动。
   - 贪心策略：总是选择结束时间最早的活动，从而留给未来尽可能多的时间进行其他活动。

2. **霍夫曼编码**
   - 描述：用于数据压缩。给定一组字符及其频率，构造最优的变长前缀码。
   - 贪心策略：频率越高的字符被赋予越短的编码，通过构建一棵霍夫曼树实现。

3. **最小生成树**
   - 描述：给定一个带权重的无向图，找到连接所有顶点而总边权重最小的子图。
   - 贪心策略：可以用Prim算法或Kruskal算法，都是贪心算法的体现，选择最小权重的边，而不形成环。

4. **单源最短路径问题**
   - 描述：在加权图中找到从单一源点到所有其他顶点的最短路径。
   - 贪心策略：Dijkstra算法，每次选择最近的未访问顶点。

5. **零钱兑换问题**
   - 描述：给定不同面额的硬币和一个总金额，找到硬币数最少的方式来凑成该金额。
   - 贪心策略：优先使用最大面额的硬币，直到无法使用为止（注意：仅当硬币面额的组合是特定的，如美国货币系统，该策略才能保证得到最优解）。

6. **装载问题（背包问题的一种特例）**
   - 描述：有一系列物品和一个背包，物品有重量和价值，背包有载重限制，求不超过载重时的最大价值。
   - 贪心策略：以单位重量价值（价值/重量）为标准进行排序，优先选择单位价值最高的物品装入背包（注意：这是分数背包问题的贪心解法，对于0-1背包问题，贪心算法无法保证最优解）。

7. **区间覆盖问题**
   - 描述：给定一系列区间和一个目标区间，选择最少的子区间完全覆盖目标区间。
   - 贪心策略：每次选择可以覆盖当前未覆盖部分的最左端点的区间。


## 动态规划
### 树形DP：01背包问题
给定一个固定容量为W的背包和一组n个物品，每个物品有自己的重量w[i]和价值v[i]。目标是选择一些物品装入背包，使得这些物品的总重量不超过背包的容量，同时使得这些物品的总价值最大。
```python
def knapsack(W, weights, values, n):
    # dp[i][j] 表示考虑前i个物品，背包容量为j时的最大价值
    dp = [[0] * (W + 1) for _ in range(n + 1)]

    # 填充动态规划表
    for i in range(1, n + 1):
        for j in range(1, W + 1):
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1])
            else:
                dp[i][j] = dp[i-1][j]
    return dp[n][W]
```
### 线性DP：最长公共子序列、最长公共子串
给定两个字符串s1和s2，找到这两个字符串的最长公共子序列的长度。子序列是指从一个序列中删除一些或不删除任何元素，且不改变剩余元素的顺序得到的新序列。
```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```
### 区间DP：矩阵最大值（和以及积）
给定一个矩阵，找到其中的一个子矩阵，使得这个子矩阵的元素和最大。
```python
def max_submatrix_sum(matrix):
    if not matrix or not matrix[0]:
        return 0
    max_sum = float('-inf')
    rows, cols = len(matrix), len(matrix[0])

    for left in range(cols):
        temp = [0] * rows
        for right in range(left, cols):
            for i in range(rows):
                temp[i] += matrix[i][right]
            max_sum = max(max_sum, max_subarray_sum(temp))
    return max_sum

def max_subarray_sum(arr):
    max_ending_here = max_so_far = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
```
### 数位DP：数字游戏
https://www.acwing.com/solution/content/66855/
给定两个数A和B，找出这两个数之间（包括A和B）满足某种特定条件（如数字的和为偶数）的数字个数。
```python
def digit_dp(num):
    digits = list(map(int, str(num)))
    n = len(digits)
    # dp[pos][tight][state]，其中pos是当前位置，tight表示是否贴合上界，state表示当前状态
    dp = [[-1] * state_size for _ in range(n)]
    
    def dfs(pos, tight, state):
        if pos == n:
            return 1 if state满足条件 else 0
        if dp[pos][tight][state] != -1:
            return dp[pos][tight][state]
        limit = digits[pos] if tight else 9
        result = 0
        for dig in range(limit + 1):
            result += dfs(pos + 1, tight and dig == limit, new_state_based_on(dig, state))
        dp[pos][tight][state] = result
        return result
    
    return dfs(0, True, initial_state)
```
### 状态压缩DP：旅行商
给定一组城市和每对城市之间的旅行成本，找到通过每个城市一次最后回到起始城市的最短路径。
```python
def tsp(cost):
    n = len(cost)
    dp = [[float('inf')] * (1 << n) for _ in range(n)]
    dp[0][1] = 0  # 从城市0开始

    for mask in range(1 << n):
        for u in range(n):
            if mask & (1 << u):
                for v in range(n):
                    if mask & (1 << v) == 0:
                        next_mask = mask | (1 << v)
                        dp[v][next_mask] = min(dp[v][next_mask], dp[u][mask] + cost[u][v])
    
    return min(dp[i][(1 << n) - 1] + cost[i][0] for i in range(1, n))
```
## 排序
### 插入排序、选择排序、冒泡排序
### 分治排序：快速排序、归并排序
### 分配排序：桶排序、基数排序
### 树状排序：堆排序（必学）

## 搜索和回溯
### 启发式搜索算法：A*寻路算法
### 地图着色算法、N 皇后问题、最优加工顺序
### 旅行商问题

## 树算法

## 图算法
### 图的表示：邻接矩阵和邻接表
### 遍历算法：深度搜索和广度搜索(必学)
### 最短路径算法：Floyd，Dijkstra（必学）
### 最小生成树算法：Prim，Kruskal（必学）
### 实际常用算法：关键路径、拓扑排序（原理与应用）
### 二分图匹配：配对、匈牙利算法（原理与应用）

# 数据结构
## 列表
- 数组（array，numpy），列表是 list，python 自带
## 链表
#20 
## 并查集/哈希表
### 碰撞解决方法：开放定址法、链地址法、再次哈希法、建立公共溢出区
### 布隆过滤器（原理与应用）
#23 
## 栈/队列
#21 
## 优先队列和堆
#22 

## 树
#24 
### 二叉树：各种遍历（递归与非递归）
### 哈夫曼树与编码（原理与应用）
### AVL树（必学）
### B 树与 B+ 树（原理与应用）
### 前缀树（原理与应用）
### 红黑树（原理与应用）
### 线段树（原理与应用）

## 字符匹配算法
### 正则表达式
### 模式匹配：KMP、Boyer-Moore

## 流算法
### 最大流：最短增广路、Dinic 算法
### 最大流最小割：最大收益问题、方格取数问题
### 最小费用最大流：最小费用路、消遣