<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>笔记</title><link>https://stayt2.github.io</link><description>博观而约取，厚积而薄发</description><copyright>笔记</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://stayt2.github.io</link></image><lastBuildDate>Mon, 02 Sep 2024 07:37:54 +0000</lastBuildDate><managingEditor>笔记</managingEditor><ttl>60</ttl><webMaster>笔记</webMaster><item><title>队列/栈</title><link>https://stayt2.github.io/post/dui-lie---zhan.html</link><description>- deque: 提供了一个双端队列，支持从前端或后端以近乎 O(1) 的复杂度添加或删除元素。</description><guid isPermaLink="true">https://stayt2.github.io/post/dui-lie---zhan.html</guid><pubDate>Mon, 02 Sep 2024 07:34:12 +0000</pubDate></item><item><title>链表</title><link>https://stayt2.github.io/post/lian-biao.html</link><description>变体有双向链表，循环链表&#13;
```python&#13;
from llist import sllist, dllist&#13;
&#13;
# 单链表&#13;
sl = sllist([1, 2, 3])&#13;
print(sl)  # 输出: [1, 2, 3]&#13;
&#13;
# 双链表&#13;
dl = dllist([10, 20, 30])&#13;
print(dl)  # 输出: [10, 20, 30]&#13;
```&#13;
```python&#13;
class ListNode:&#13;
    def __init__(self, x):&#13;
        self.val = x&#13;
        self.next = None&#13;
```&#13;
一个标准有效的 链表是&#13;
&#13;
1. 关键点一、同时持有头尾节点的引用，好处是对于头尾的操作直接是O(1)&#13;
2. 关键点二、虚拟头尾节点, 好处是不会存在越界问题&#13;
&#13;
对应题目： https://leetcode.cn/problems/design-linked-list/submissions/&#13;
&#13;
下面是一个标准的 链表 的实现：&#13;
```python&#13;
class Node:&#13;
    def __init__(self, data=None):&#13;
        self.data = data&#13;
        self.next = None&#13;
&#13;
class LinkedList:&#13;
    def __init__(self):&#13;
        # 初始化虚拟头尾节点&#13;
        self.head = Node()  # 虚拟头节点&#13;
        self.tail = Node()  # 虚拟尾节点&#13;
        self.head.next = self.tail  # 头节点指向尾节点&#13;
        self.size = 0  # 链表的长度&#13;
&#13;
    def is_empty(self):&#13;
        return self.size == 0&#13;
&#13;
    def insert_at_end(self, data):&#13;
        new_node = Node(data)&#13;
        current = self.head&#13;
        while current.next != self.tail:&#13;
            current = current.next&#13;
        current.next = new_node&#13;
        new_node.next = self.tail&#13;
        self.size += 1&#13;
&#13;
    def insert_at_beginning(self, data):&#13;
        new_node = Node(data)&#13;
        new_node.next = self.head.next&#13;
        self.head.next = new_node&#13;
        self.size += 1&#13;
&#13;
    def delete(self, data):&#13;
        current = self.head&#13;
        while current.next != self.tail:&#13;
            if current.next.data == data:&#13;
                current.next = current.next.next&#13;
                self.size -= 1&#13;
                return True&#13;
            current = current.next&#13;
        return False&#13;
&#13;
    def search(self, data):&#13;
        current = self.head.next&#13;
        while current != self.tail:&#13;
            if current.data == data:&#13;
                return True&#13;
            current = current.next&#13;
        return False&#13;
&#13;
    def update(self, old_data, new_data):&#13;
        current = self.head.next&#13;
        while current != self.tail:&#13;
            if current.data == old_data:&#13;
                current.data = new_data&#13;
                return True&#13;
            current = current.next&#13;
        return False&#13;
&#13;
    def display(self):&#13;
        current = self.head.next&#13;
        while current != self.tail:&#13;
            print(current.data, end=' -&gt; ')&#13;
            current = current.next&#13;
        print('None')&#13;
&#13;
    def list_to_linked_list(self, lst):&#13;
        for data in lst:&#13;
            self.insert_at_end(data)&#13;
&#13;
# 使用示例&#13;
ll = LinkedList()&#13;
&#13;
# 插入节点&#13;
ll.insert_at_end(1)&#13;
ll.insert_at_end(2)&#13;
ll.insert_at_end(3)&#13;
ll.display()  # 输出: 1 -&gt; 2 -&gt; 3 -&gt; None&#13;
&#13;
# 在头部插入节点&#13;
ll.insert_at_beginning(0)&#13;
ll.display()  # 输出: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; None&#13;
&#13;
# 删除节点&#13;
ll.delete(2)&#13;
ll.display()  # 输出: 0 -&gt; 1 -&gt; 3 -&gt; None&#13;
&#13;
# 查找节点&#13;
print(ll.search(3))  # 输出: True&#13;
print(ll.search(4))  # 输出: False&#13;
&#13;
# 更新节点&#13;
ll.update(1, 10)&#13;
ll.display()  # 输出: 0 -&gt; 10 -&gt; 3 -&gt; None&#13;
&#13;
# 将列表转换为链表&#13;
ll2 = LinkedList()&#13;
ll2.list_to_linked_list([4, 5, 6])&#13;
ll2.display()  # 输出: 4 -&gt; 5 -&gt; 6 -&gt; None&#13;
&#13;
```&#13;
# 算法&#13;
## 反转链表&#13;
&#13;
```python&#13;
class Node:&#13;
    def __init__(self, data):&#13;
        self.data = data&#13;
        self.next = None&#13;
&#13;
class LinkedList:&#13;
    def __init__(self):&#13;
        self.head = None&#13;
&#13;
    def append(self, data):&#13;
        new_node = Node(data)&#13;
        if not self.head:&#13;
            self.head = new_node&#13;
        else:&#13;
            current = self.head&#13;
            while current.next:&#13;
                current = current.next&#13;
            current.next = new_node&#13;
&#13;
    def reverse(self):&#13;
        prev = None&#13;
        current = self.head&#13;
        while current:&#13;
            next_node = current.next&#13;
            current.next = prev&#13;
            prev = current&#13;
            current = next_node&#13;
        self.head = prev&#13;
&#13;
    def display(self):&#13;
        current = self.head&#13;
        while current:&#13;
            print(current.data, end=' -&gt; ')&#13;
            current = current.next&#13;
        print('None')&#13;
&#13;
# 使用示例&#13;
ll = LinkedList()&#13;
ll.append(1)&#13;
ll.append(2)&#13;
ll.append(3)&#13;
ll.display()  # 输出: 1 -&gt; 2 -&gt; 3 -&gt; None&#13;
ll.reverse()&#13;
ll.display()  # 输出: 3 -&gt; 2 -&gt; 1 -&gt; None&#13;
&#13;
```&#13;
&#13;
## 检测链表中的环&#13;
环形链表是指链表中存在一个节点指向之前某个节点的情况。</description><guid isPermaLink="true">https://stayt2.github.io/post/lian-biao.html</guid><pubDate>Mon, 02 Sep 2024 07:33:53 +0000</pubDate></item><item><title>算法与数据结构</title><link>https://stayt2.github.io/post/suan-fa-yu-shu-ju-jie-gou.html</link><description># 算法分析&#13;
Python 一些常见的算法库：&#13;
1. collections - 这个模块提供了许多扩展的容器类型：&#13;
&#13;
    - deque: 提供了一个双端队列，支持从前端或后端以近乎 O(1) 的复杂度添加或删除元素。</description><guid isPermaLink="true">https://stayt2.github.io/post/suan-fa-yu-shu-ju-jie-gou.html</guid><pubDate>Mon, 02 Sep 2024 07:33:25 +0000</pubDate></item><item><title>Gmeek 教程</title><link>https://stayt2.github.io/post/Gmeek%20-jiao-cheng.html</link><description>&gt; [!NOTE]&#13;
&gt; Useful information that users should know, even when skimming content.&#13;
&#13;
&gt; [!TIP]&#13;
&gt; Helpful advice for doing things better or more easily.&#13;
&#13;
&gt; [!IMPORTANT]&#13;
&gt; Key information users need to know to achieve their goal.&#13;
&#13;
&gt; [!WARNING]&#13;
&gt; Urgent info that needs immediate user attention to avoid problems.&#13;
&#13;
&gt; [!CAUTION]&#13;
&gt; Advises about risks or negative outcomes of certain actions.&#13;
&#13;
# iframe&#13;
`Gmeek-html&lt;img src='https://picsum.photos/200'&gt;`&#13;
&#13;
`Gmeek-html&lt;iframe style='border-radius:12px' src='https://open.spotify.com/embed/track/0U3fV7K4WFfVRgLGEAKh3g?utm_source=generator' width='100%' height='152' frameBorder='0' allowfullscreen='' allow='autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture' loading='lazy'&gt;&lt;/iframe&gt;`&#13;
。</description><guid isPermaLink="true">https://stayt2.github.io/post/Gmeek%20-jiao-cheng.html</guid><pubDate>Mon, 02 Sep 2024 07:32:46 +0000</pubDate></item><item><title>关于</title><link>https://stayt2.github.io/about.html</link><description>- 南开大学, 统计与数据科学学院，数据科学与大数据技术&#13;
- KAUST, CEMSE, Visiting Student&#13;
- HKUST, CSE, Research Assistant&#13;
- 南开大学，网络空间安全，计算机技术&#13;
- 中国移动，移动研究院，实习&#13;
- 快手科技，内容与风险技术部，实习&#13;
&#13;
兴趣：机器学习理论，机器学习安全，大模型安全。</description><guid isPermaLink="true">https://stayt2.github.io/about.html</guid><pubDate>Mon, 02 Sep 2024 07:13:43 +0000</pubDate></item></channel></rss>