<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title> </title><link>https://stayt2.github.io</link><description> </description><copyright> </copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://stayt2.github.io/touxiang.jpg</url><title>avatar</title><link>https://stayt2.github.io</link></image><lastBuildDate>Fri, 20 Sep 2024 16:10:41 +0000</lastBuildDate><managingEditor> </managingEditor><ttl>60</ttl><webMaster> </webMaster><item><title>编辑距离</title><link>https://stayt2.github.io/post/bian-ji-ju-li.html</link><description>- 动态规划。</description><guid isPermaLink="true">https://stayt2.github.io/post/bian-ji-ju-li.html</guid><pubDate>Fri, 20 Sep 2024 07:26:29 +0000</pubDate></item><item><title>LoRA 技术详解</title><link>https://stayt2.github.io/post/LoRA%20-ji-shu-xiang-jie.html</link><description># Adapter Tuning&#13;
# Prefix Tuning&#13;
# Prompt Tuning&#13;
# P-Tuning&#13;
# P-Tuning v2 &#13;
# LoRA &#13;
# QLoRA&#13;
&#13;
&#13;
# 改进。</description><guid isPermaLink="true">https://stayt2.github.io/post/LoRA%20-ji-shu-xiang-jie.html</guid><pubDate>Sat, 07 Sep 2024 10:24:14 +0000</pubDate></item><item><title>Python 全栈学习路线</title><link>https://stayt2.github.io/post/Python%20-quan-zhan-xue-xi-lu-xian.html</link><description># Web开发&#13;
- Django、Flask。</description><guid isPermaLink="true">https://stayt2.github.io/post/Python%20-quan-zhan-xue-xi-lu-xian.html</guid><pubDate>Wed, 04 Sep 2024 09:56:12 +0000</pubDate></item><item><title>Leetcode 刷题笔记</title><link>https://stayt2.github.io/post/Leetcode%20-shua-ti-bi-ji.html</link><description>- TODO。</description><guid isPermaLink="true">https://stayt2.github.io/post/Leetcode%20-shua-ti-bi-ji.html</guid><pubDate>Wed, 04 Sep 2024 09:53:19 +0000</pubDate></item><item><title>Chiikawa</title><link>https://stayt2.github.io/post/Chiikawa.html</link><description>![wp12429177-chiikawa-wallpapers](https://github.com/user-attachments/assets/369f1a5d-b73e-4485-b07e-a2e6061d73ce)&#13;
。</description><guid isPermaLink="true">https://stayt2.github.io/post/Chiikawa.html</guid><pubDate>Mon, 02 Sep 2024 18:13:29 +0000</pubDate></item><item><title>生命力旺盛的人 </title><link>https://stayt2.github.io/post/sheng-ming-li-wang-sheng-de-ren-%20.html</link><description># 生命力旺盛的人&#13;
生命力旺盛的人往往能点燃别人对于生命的激情和希望，有时候人想要继续生活下去，不一定需要多么丰富的物质和具体的解决方案，有时候仅仅是需要被人带动进入一个好的状态，一切困扰就会迎刃而解。</description><guid isPermaLink="true">https://stayt2.github.io/post/sheng-ming-li-wang-sheng-de-ren-%20.html</guid><pubDate>Mon, 02 Sep 2024 07:45:17 +0000</pubDate></item><item><title>Github Markdown 高级用法</title><link>https://stayt2.github.io/post/Github%20Markdown%20-gao-ji-yong-fa.html</link><description>- 斜体：`*斜体文本*`&#13;
- 粗体：`**粗体文本**`&#13;
- 分割线：`***`&#13;
- 脚注：`[^tag], 然后 [^tag]: 就行`&#13;
- 代码： ` ```javascript````&#13;
 ```javascript&#13;
$(document).ready(function () {&#13;
    alert('RUNOOB');&#13;
});&#13;
```&#13;
- 链接：`[链接名称](链接地址)`&#13;
- 图片：`![alt 属性文本](图片地址 '可选标题')`&#13;
- 表格：   |  表头   | 表头  | |  ----  | ----  |&#13;
&#13;
&#13;
|  表头   | 表头  |&#13;
|  ----  | ----  |&#13;
| 单元格  | 单元格 |&#13;
| 单元格  | 单元格 |&#13;
&#13;
流程图：&#13;
&#13;
&#13;
```mermaid&#13;
graph LR&#13;
A[方形] --&gt;B(圆角)&#13;
    B --&gt; C{条件a}&#13;
    C --&gt;|a=1| D[结果1]&#13;
    C --&gt;|a=2| E[结果2]&#13;
    F[横向流程图]&#13;
```。</description><guid isPermaLink="true">https://stayt2.github.io/post/Github%20Markdown%20-gao-ji-yong-fa.html</guid><pubDate>Mon, 02 Sep 2024 07:44:38 +0000</pubDate></item><item><title>想法AES1 </title><link>https://stayt2.github.io/post/xiang-fa-AES1%20.html</link><description>U2FsdGVkX18LXtG/bU7PJ7OP0jg5NWgPjLtpK6Qz8ydg+7oXAqWTZjVGT+JGcTZW Ws4FZPm6uo3pfWmO67I5WmDCN+GRsFWktJI8Ee1jqCZQYjndDVjUdYjmtrqAecFh cMs9J2MaCc816m+EHwxCPWE/CpLi4yJi9a5v2Co8WFySUcR0ZmDVouTlM4kHt+P9 R8Tj8T+VNcOulpONJtHSEbSQI6EyQxBJfL/zQkHmmT/ewkJGhDR+mnKsG6/FWWil H3/cwjylqNE+/puq4KtyT9hi0vIkaePjja1pXN7mnfrvBppbnKJzPpU5hAF3b7Yj SLw6lOgaoBBecYtwkd/RRRK3sz+H/t9qlnK/VKgJTLfeIr22JPL3hGn+GdJ/1WxJ QyKtnU3gzzJxRBd7oo0HPRmlRQBMgVKXNYjv2UqCe095e3pIab/JZbnrB1S2/zA7 3nLfRi1xz+VflKfrq7HAEUuvIckQvNohMYLL5E/pGwlKOJSrRGwJabMB/s/cC1Dr zHa3bIRCRl/8zfHBc1E5uh29++uZ38kDZDRvF3pYJPVuiUa47/90YmwqOfNvJ053 6a0aS+V07SGI4ZPuH4gLohO2werKDOz1jgemBo4t8OY=    https://tool.oschina.net/encrypt。</description><guid isPermaLink="true">https://stayt2.github.io/post/xiang-fa-AES1%20.html</guid><pubDate>Mon, 02 Sep 2024 07:43:08 +0000</pubDate></item><item><title>Beam Search 模板</title><link>https://stayt2.github.io/post/Beam%20Search%20-mo-ban.html</link><description>```python&#13;
&#13;
import torch&#13;
import torch.nn.functional as F&#13;
&#13;
class Beam:&#13;
    def __init__(self, token, logp, h, sequence):&#13;
        # 初始化beam对象&#13;
        self.token = token  # 当前token&#13;
        self.logp = logp  # 当前token的对数概率&#13;
        self.h = h  # 隐藏状态&#13;
        self.sequence = sequence  # 到目前为止的序列&#13;
        self.done = (token == VOCAB+1)  # 判断是否到达序列结束标记EOS&#13;
&#13;
    def extend(self, token, logp, h):&#13;
        # 扩展当前beam，返回新的beam实例&#13;
        return Beam(token, self.logp + logp, h, self.sequence + [token])&#13;
&#13;
&#13;
def beam_search(model, inp, beam_width=5, max_decoding_len=15, top_k=10):&#13;
    # 使用beam search算法进行解码&#13;
    model.eval()  # 设置模型为评估模式&#13;
    with torch.no_grad():  # 不计算梯度&#13;
        inp = inp.to(device)  # 将输入移到设备上&#13;
        out_enc, h = model.enc(model.emb(inp))  # 编码器部分&#13;
        out_enc = model.DP(out_enc)  # 应用dropout&#13;
        h = h.view((1, inp.shape[0], 2 * model.HID))  # 调整隐藏状态的形状&#13;
&#13;
        start_token = char_to_idx['begin']  # 开始token&#13;
        beam = [Beam(start_token, 0.0, h, [start_token])]  # 初始化beam列表&#13;
&#13;
        for _ in range(max_decoding_len):  # 最大解码长度&#13;
            new_beam = []&#13;
&#13;
            for b in beam:&#13;
                if b.done:&#13;
                    new_beam.append(b)  # 如果完成则直接添加到新beam列表&#13;
                    continue&#13;
&#13;
                dec_inp = torch.tensor([[b.token]], dtype=torch.long, device=device)  # 准备解码器的输入&#13;
                dec_out, h_new = model.run_dec(dec_inp, out_enc, b.h)  # 解码器运行&#13;
                log_probs = F.log_softmax(dec_out, dim=-1)  # 使用log_softmax获取概率&#13;
&#13;
                top_k_log_probs, top_k_tokens = torch.topk(log_probs, beam_width)  # 获取top_k概率和对应的tokens&#13;
&#13;
                for i in range(beam_width):&#13;
                    token = top_k_tokens[0, 0, i].item()  # 获取token&#13;
                    logp = top_k_log_probs[0, 0, i].item()  # 获取对数概率&#13;
                    new_beam.append(b.extend(token, logp, h_new))  # 扩展beam&#13;
&#13;
            beam = sorted(new_beam, key=lambda x: x.logp / len(x.sequence), reverse=True)[:beam_width]  # 排序并保留最好的beam_width个beam&#13;
&#13;
        # 返回分数最高的top_k个序列&#13;
        return [b.sequence for b in sorted(beam, key=lambda x: x.logp / len(x.sequence), reverse=True)[:top_k]]&#13;
```。</description><guid isPermaLink="true">https://stayt2.github.io/post/Beam%20Search%20-mo-ban.html</guid><pubDate>Mon, 02 Sep 2024 07:41:52 +0000</pubDate></item><item><title>机器学习面试常见问题 - hard</title><link>https://stayt2.github.io/post/ji-qi-xue-xi-mian-shi-chang-jian-wen-ti-%20-%20hard.html</link><description># 细节的东西都难&#13;
&#13;
&#13;
# 其他问题：开发，测试，安全技术&#13;
&#13;
- Python常见问题&#13;
&#13;
1. 深拷贝，浅拷贝&#13;
&#13;
&#13;
# 智力题。</description><guid isPermaLink="true">https://stayt2.github.io/post/ji-qi-xue-xi-mian-shi-chang-jian-wen-ti-%20-%20hard.html</guid><pubDate>Mon, 02 Sep 2024 07:41:33 +0000</pubDate></item><item><title>机器学习面试常见问题 - medium</title><link>https://stayt2.github.io/post/ji-qi-xue-xi-mian-shi-chang-jian-wen-ti-%20-%20medium.html</link><description># 数学中级&#13;
&#13;
# NLP&#13;
&#13;
# RL/GAN&#13;
&#13;
# 大模型&#13;
&#13;
# 推荐系统/高斯过程&#13;
。</description><guid isPermaLink="true">https://stayt2.github.io/post/ji-qi-xue-xi-mian-shi-chang-jian-wen-ti-%20-%20medium.html</guid><pubDate>Mon, 02 Sep 2024 07:41:21 +0000</pubDate></item><item><title>机器学习面试常见问题 - easy</title><link>https://stayt2.github.io/post/ji-qi-xue-xi-mian-shi-chang-jian-wen-ti-%20-%20easy.html</link><description>机器学习和人类学习有着千丝万缕的联系，人类试图构建一些学会学习（Learning to learn）的方式教给电脑/算法以学习人类的学习方法。</description><guid isPermaLink="true">https://stayt2.github.io/post/ji-qi-xue-xi-mian-shi-chang-jian-wen-ti-%20-%20easy.html</guid><pubDate>Mon, 02 Sep 2024 07:41:07 +0000</pubDate></item><item><title>面试代码题目</title><link>https://stayt2.github.io/post/mian-shi-dai-ma-ti-mu.html</link><description># 第 k 大的数组&#13;
&#13;
```python&#13;
class Solution:&#13;
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:&#13;
        # 交换位置i和位置j的元素&#13;
        def swap(i: int, j: int):&#13;
            nums[i], nums[j] = nums[j], nums[i]&#13;
&#13;
        # 对[left, right]范围内的元素进行降序快排，找到第k大元素&#13;
        def quick_sort_kth_element(k: int, left: int, right: int) -&gt; int:&#13;
            mid = (right + left) // 2    # 选取中间元素作为切分值&#13;
            swap(mid, right)             # 将切分值放到右边界避免加入元素的划分&#13;
            partition, i, j = nums[right], left, right   # 双指针从左右边界开始，分别找到要交换的元素&#13;
            while i &lt; j:&#13;
                while i &lt; j and nums[i] &gt;= partition: i += 1    # 找到左侧小于切分值的元素&#13;
                while j &gt; i and nums[j] &lt;= partition: j -=1    # 找到右侧大于切分值的元素【因为是找大于，即使j从right开始，right也不会被选中】&#13;
                if i &lt; j:&#13;
                    swap(i, j)     # 将大于元素放到左侧，小于元素放到右侧&#13;
            swap(i, right)     # i最后停留的位置一定是右侧首个小于切分值的元素，与切分值交换，则[left, i)都是大于（等于）切分值，[i+1, right]都是小于（等于）切分值&#13;
            if i == k - 1: return nums[i]   # 如果切分值就是第k大元素，直接返回&#13;
            if i &lt; k - 1: return quick_sort_kth_element(k, i + 1, right)     # 切分值是第k大之前的元素，在右区间搜索第k大&#13;
            return quick_sort_kth_element(k, left, i - 1)   # 切分值是第k大之后的元素，在左区间搜索第k大&#13;
        &#13;
        return quick_sort_kth_element(k, 0, len(nums) - 1)    # 快排整个区间&#13;
&#13;
链接：https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/2647778/javapython3cdui-pai-xu-kuai-su-pai-xu-ji-jcb9/&#13;
&#13;
```&#13;
&#13;
https://leetcode.cn/studyplan/top-100-liked/&#13;
&#13;
Hot100一定要刷完&#13;
&#13;
# 腾讯&#13;
- 一个数组第 k 大的数字&#13;
&#13;
# 百度&#13;
- 最长递增子序列&#13;
- 中位数查找问题&#13;
# 华泰&#13;
&#13;
# 360&#13;
- 一个easy题目&#13;
- 一个表达式随机插入一个数字之后能否相等&#13;
# 作业帮&#13;
- 一个medium题目&#13;
&#13;
# 科大讯飞&#13;
&#13;
# 长鑫存储&#13;
- easy题目&#13;
- 房租分配问题&#13;
&#13;
# 美团&#13;
&#13;
# 360&#13;
&#13;
# 讯飞&#13;
&#13;
# 文远&#13;
&#13;
#  Robosense&#13;
&#13;
# 九坤&#13;
&#13;
# 字节&#13;
&gt; 给定一个数n，如23121;给定一组数字A如{2,4,9}，求由A中元素组成的小于n的最大数，如小于23121的最大数为 22999&#13;
&#13;
```python&#13;
def find_max_less_than_n(n, A):&#13;
    # 将n转化为字符数组，方便处理每一位数字&#13;
    digits = list(str(n))&#13;
    # 对A进行排序，确保可以从大到小尝试&#13;
    A = sorted(A, reverse=True)&#13;
    &#13;
    def backtrack(index):&#13;
        if index &lt; 0:&#13;
            # 如果回溯超出最高位，则返回A中最大元素组成的小于n的最大数&#13;
            return str(A[0]) * int(len(digits)-1)&#13;
        &#13;
        original = int(digits[index])  # 保存原始数字&#13;
        for a in A:&#13;
            # 从大到小尝试替换当前位的数字&#13;
            if a &lt; original:&#13;
                digits[index] = str(a)&#13;
                # 将后面的所有位替换成A中最大的数字&#13;
                for i in range(index + 1, len(digits)):&#13;
                    digits[i] = str(A[0])&#13;
                return ''.join(digits)&#13;
        # 如果所有的数字都不能替换当前位&#13;
        # 那么回溯到上一位&#13;
        digits[index] = str(original)&#13;
        return backtrack(index - 1)&#13;
    &#13;
    # 从最高位开始回溯&#13;
    return backtrack(len(digits) - 1)&#13;
&#13;
# 给定的数字&#13;
n = 23121&#13;
# 给定的数字集合A&#13;
A = [2, 4, 9]&#13;
# 打印结果&#13;
print(find_max_less_than_n(n, A))  # 输出应该是22999&#13;
&#13;
# 对于第二个例子&#13;
n = 22121&#13;
print(find_max_less_than_n(n, A))  # 输出应该是9999&#13;
```&#13;
&#13;
# 滑动窗口问题&#13;
&#13;
https://leetcode.cn/problems/minimum-size-subarray-sum/description/&#13;
&#13;
```python&#13;
def min_sub_len(s, nums):&#13;
    n = len(nums)&#13;
    min_len = float('inf')  # 初始化最小长度为无穷大&#13;
    left = 0  # 初始化左指针&#13;
    cur = 0  # 初始化当前和为0&#13;
    for right in range(n):  # 右指针在数组上滑动&#13;
        cur += nums[right]  # 将当前右指针指向的值加到当前和中&#13;
        while cur &gt;= s:  # 当当前和大于等于s时，尝试缩小窗口&#13;
            min_len = min(min_len, right - left + 1)  # 更新最小长度&#13;
            cur -= nums[left]  # 从当前和中减去左指针指向的值&#13;
            left += 1  # 移动左指针&#13;
    return min_len if min_len != float('inf') else 0  # 如果找到了子数组，返回最小长度；否则返回0&#13;
```&#13;
这个题有个坑的地方就是 while 容易写成 if &#13;
&#13;
这种方法能找到最小长度的数组，是因为它遵循了两个关键的策略：&#13;
&#13;
- 策略一：递增窗口以满足最小和要求&#13;
当窗口中的元素总和小于 s 时，我们通过向右移动 right 指针来增加窗口的大小。</description><guid isPermaLink="true">https://stayt2.github.io/post/mian-shi-dai-ma-ti-mu.html</guid><pubDate>Mon, 02 Sep 2024 07:40:37 +0000</pubDate></item><item><title>树/图</title><link>https://stayt2.github.io/post/shu---tu.html</link><description># 二叉树&#13;
```python&#13;
class TreeNode:&#13;
    def __init__(self, value):&#13;
        self.value = value&#13;
        self.left = None&#13;
        self.right = None&#13;
```&#13;
## 遍历&#13;
```python&#13;
class BinaryTree:&#13;
    def __init__(self):&#13;
        self.root = None&#13;
&#13;
    def inorder_traversal(self):&#13;
        '''中序遍历二叉树'''&#13;
        return self._inorder_recursive(self.root)&#13;
    &#13;
    def _inorder_recursive(self, node):&#13;
        result = []&#13;
        if node:&#13;
            result = self._inorder_recursive(node.left)&#13;
            result.append(node.value)&#13;
            result.extend(self._inorder_recursive(node.right))&#13;
        return result&#13;
&#13;
    def preorder_traversal(self):&#13;
        '''前序遍历二叉树'''&#13;
        return self._preorder_recursive(self.root)&#13;
    &#13;
    def _preorder_recursive(self, node):&#13;
        result = []&#13;
        if node:&#13;
            result.append(node.value)&#13;
            result.extend(self._preorder_recursive(node.left))&#13;
            result.extend(self._preorder_recursive(node.right))&#13;
        return result&#13;
&#13;
    def postorder_traversal(self):&#13;
        '''后序遍历二叉树'''&#13;
        return self._postorder_recursive(self.root)&#13;
    &#13;
    def _postorder_recursive(self, node):&#13;
        result = []&#13;
        if node:&#13;
            result.extend(self._postorder_recursive(node.left))&#13;
            result.extend(self._postorder_recursive(node.right))&#13;
            result.append(node.value)&#13;
        return result&#13;
&#13;
# 创建二叉树实例&#13;
bt = BinaryTree()&#13;
bt.insert(10)&#13;
bt.insert(5)&#13;
bt.insert(15)&#13;
bt.insert(3)&#13;
bt.insert(7)&#13;
bt.insert(13)&#13;
bt.insert(18)&#13;
&#13;
# 遍历输出&#13;
print('Inorder Traversal:', bt.inorder_traversal())&#13;
print('Preorder Traversal:', bt.preorder_traversal())&#13;
print('Postorder Traversal:', bt.postorder_traversal())&#13;
```&#13;
## 搜索&#13;
### 深度优先搜索&#13;
即三种遍历算法&#13;
### 宽度优先搜索&#13;
即层次遍历&#13;
```python&#13;
class TreeNode:&#13;
    def __init__(self, value):&#13;
        self.value = value&#13;
        self.left = None&#13;
        self.right = None&#13;
&#13;
class BinaryTree:&#13;
    def __init__(self):&#13;
        self.root = None&#13;
    &#13;
    def dfs_preorder(self):&#13;
        return self._dfs_preorder(self.root, [])&#13;
    &#13;
    def _dfs_preorder(self, node, result):&#13;
        if node:&#13;
            result.append(node.value)  # 访问节点&#13;
            self._dfs_preorder(node.left, result)  # 遍历左子树&#13;
            self._dfs_preorder(node.right, result)  # 遍历右子树&#13;
        return result&#13;
&#13;
    def bfs(self):&#13;
        result = []&#13;
        if not self.root:&#13;
            return result&#13;
        queue = [self.root]&#13;
        while queue:&#13;
            node = queue.pop(0)&#13;
            result.append(node.value)  # 访问节点&#13;
            if node.left:&#13;
                queue.append(node.left)&#13;
            if node.right:&#13;
                queue.append(node.right)&#13;
        return result&#13;
&#13;
# 创建二叉树实例&#13;
bt = BinaryTree()&#13;
bt.root = TreeNode(1)&#13;
bt.root.left = TreeNode(2)&#13;
bt.root.right = TreeNode(3)&#13;
bt.root.left.left = TreeNode(4)&#13;
bt.root.left.right = TreeNode(5)&#13;
&#13;
# DFS 先序遍历输出&#13;
print('DFS Preorder:', bt.dfs_preorder())&#13;
# BFS 层次遍历输出&#13;
print('BFS:', bt.bfs())&#13;
```&#13;
### 计算树的高度和深度&#13;
&#13;
- 计算树的高度：树的高度是从根节点到最远叶子节点的最长路径上的节点数。</description><guid isPermaLink="true">https://stayt2.github.io/post/shu---tu.html</guid><pubDate>Mon, 02 Sep 2024 07:39:57 +0000</pubDate></item><item><title>并查集/哈希表 </title><link>https://stayt2.github.io/post/bing-cha-ji---ha-xi-biao-%20.html</link><description># 并查集&#13;
并查集是一种数据结构，特别适用于处理一些不交集的合并及查询问题。</description><guid isPermaLink="true">https://stayt2.github.io/post/bing-cha-ji---ha-xi-biao-%20.html</guid><pubDate>Mon, 02 Sep 2024 07:39:41 +0000</pubDate></item><item><title>优先队列/堆</title><link>https://stayt2.github.io/post/you-xian-dui-lie---dui.html</link><description>在 Python 中，优先队列是一种特殊的数据结构，其中每个元素都与一个优先级相关联。</description><guid isPermaLink="true">https://stayt2.github.io/post/you-xian-dui-lie---dui.html</guid><pubDate>Mon, 02 Sep 2024 07:39:25 +0000</pubDate></item><item><title>队列/栈</title><link>https://stayt2.github.io/post/dui-lie---zhan.html</link><description>- deque: 提供了一个双端队列，支持从前端或后端以近乎 O(1) 的复杂度添加或删除元素。</description><guid isPermaLink="true">https://stayt2.github.io/post/dui-lie---zhan.html</guid><pubDate>Mon, 02 Sep 2024 07:34:12 +0000</pubDate></item><item><title>链表</title><link>https://stayt2.github.io/post/lian-biao.html</link><description>变体有双向链表，循环链表&#13;
```python&#13;
from llist import sllist, dllist&#13;
&#13;
# 单链表&#13;
sl = sllist([1, 2, 3])&#13;
print(sl)  # 输出: [1, 2, 3]&#13;
&#13;
# 双链表&#13;
dl = dllist([10, 20, 30])&#13;
print(dl)  # 输出: [10, 20, 30]&#13;
```&#13;
```python&#13;
class ListNode:&#13;
    def __init__(self, x):&#13;
        self.val = x&#13;
        self.next = None&#13;
```&#13;
一个标准有效的 链表是&#13;
&#13;
1. 关键点一、同时持有头尾节点的引用，好处是对于头尾的操作直接是O(1)&#13;
2. 关键点二、虚拟头尾节点, 好处是不会存在越界问题&#13;
&#13;
对应题目： https://leetcode.cn/problems/design-linked-list/submissions/&#13;
&#13;
下面是一个标准的 链表 的实现：&#13;
```python&#13;
class Node:&#13;
    def __init__(self, data=None):&#13;
        self.data = data&#13;
        self.next = None&#13;
&#13;
class LinkedList:&#13;
    def __init__(self):&#13;
        # 初始化虚拟头尾节点&#13;
        self.head = Node()  # 虚拟头节点&#13;
        self.tail = Node()  # 虚拟尾节点&#13;
        self.head.next = self.tail  # 头节点指向尾节点&#13;
        self.size = 0  # 链表的长度&#13;
&#13;
    def is_empty(self):&#13;
        return self.size == 0&#13;
&#13;
    def insert_at_end(self, data):&#13;
        new_node = Node(data)&#13;
        current = self.head&#13;
        while current.next != self.tail:&#13;
            current = current.next&#13;
        current.next = new_node&#13;
        new_node.next = self.tail&#13;
        self.size += 1&#13;
&#13;
    def insert_at_beginning(self, data):&#13;
        new_node = Node(data)&#13;
        new_node.next = self.head.next&#13;
        self.head.next = new_node&#13;
        self.size += 1&#13;
&#13;
    def delete(self, data):&#13;
        current = self.head&#13;
        while current.next != self.tail:&#13;
            if current.next.data == data:&#13;
                current.next = current.next.next&#13;
                self.size -= 1&#13;
                return True&#13;
            current = current.next&#13;
        return False&#13;
&#13;
    def search(self, data):&#13;
        current = self.head.next&#13;
        while current != self.tail:&#13;
            if current.data == data:&#13;
                return True&#13;
            current = current.next&#13;
        return False&#13;
&#13;
    def update(self, old_data, new_data):&#13;
        current = self.head.next&#13;
        while current != self.tail:&#13;
            if current.data == old_data:&#13;
                current.data = new_data&#13;
                return True&#13;
            current = current.next&#13;
        return False&#13;
&#13;
    def display(self):&#13;
        current = self.head.next&#13;
        while current != self.tail:&#13;
            print(current.data, end=' -&gt; ')&#13;
            current = current.next&#13;
        print('None')&#13;
&#13;
    def list_to_linked_list(self, lst):&#13;
        for data in lst:&#13;
            self.insert_at_end(data)&#13;
&#13;
# 使用示例&#13;
ll = LinkedList()&#13;
&#13;
# 插入节点&#13;
ll.insert_at_end(1)&#13;
ll.insert_at_end(2)&#13;
ll.insert_at_end(3)&#13;
ll.display()  # 输出: 1 -&gt; 2 -&gt; 3 -&gt; None&#13;
&#13;
# 在头部插入节点&#13;
ll.insert_at_beginning(0)&#13;
ll.display()  # 输出: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; None&#13;
&#13;
# 删除节点&#13;
ll.delete(2)&#13;
ll.display()  # 输出: 0 -&gt; 1 -&gt; 3 -&gt; None&#13;
&#13;
# 查找节点&#13;
print(ll.search(3))  # 输出: True&#13;
print(ll.search(4))  # 输出: False&#13;
&#13;
# 更新节点&#13;
ll.update(1, 10)&#13;
ll.display()  # 输出: 0 -&gt; 10 -&gt; 3 -&gt; None&#13;
&#13;
# 将列表转换为链表&#13;
ll2 = LinkedList()&#13;
ll2.list_to_linked_list([4, 5, 6])&#13;
ll2.display()  # 输出: 4 -&gt; 5 -&gt; 6 -&gt; None&#13;
&#13;
```&#13;
# 算法&#13;
## 反转链表&#13;
&#13;
```python&#13;
class Node:&#13;
    def __init__(self, data):&#13;
        self.data = data&#13;
        self.next = None&#13;
&#13;
class LinkedList:&#13;
    def __init__(self):&#13;
        self.head = None&#13;
&#13;
    def append(self, data):&#13;
        new_node = Node(data)&#13;
        if not self.head:&#13;
            self.head = new_node&#13;
        else:&#13;
            current = self.head&#13;
            while current.next:&#13;
                current = current.next&#13;
            current.next = new_node&#13;
&#13;
    def reverse(self):&#13;
        prev = None&#13;
        current = self.head&#13;
        while current:&#13;
            next_node = current.next&#13;
            current.next = prev&#13;
            prev = current&#13;
            current = next_node&#13;
        self.head = prev&#13;
&#13;
    def display(self):&#13;
        current = self.head&#13;
        while current:&#13;
            print(current.data, end=' -&gt; ')&#13;
            current = current.next&#13;
        print('None')&#13;
&#13;
# 使用示例&#13;
ll = LinkedList()&#13;
ll.append(1)&#13;
ll.append(2)&#13;
ll.append(3)&#13;
ll.display()  # 输出: 1 -&gt; 2 -&gt; 3 -&gt; None&#13;
ll.reverse()&#13;
ll.display()  # 输出: 3 -&gt; 2 -&gt; 1 -&gt; None&#13;
&#13;
```&#13;
&#13;
## 检测链表中的环&#13;
环形链表是指链表中存在一个节点指向之前某个节点的情况。</description><guid isPermaLink="true">https://stayt2.github.io/post/lian-biao.html</guid><pubDate>Mon, 02 Sep 2024 07:33:53 +0000</pubDate></item><item><title>算法与数据结构</title><link>https://stayt2.github.io/post/suan-fa-yu-shu-ju-jie-gou.html</link><description># 算法分析&#13;
Python 一些常见的算法库：&#13;
1. collections - 这个模块提供了许多扩展的容器类型：&#13;
&#13;
    - deque: 提供了一个双端队列，支持从前端或后端以近乎 O(1) 的复杂度添加或删除元素。</description><guid isPermaLink="true">https://stayt2.github.io/post/suan-fa-yu-shu-ju-jie-gou.html</guid><pubDate>Mon, 02 Sep 2024 07:33:25 +0000</pubDate></item><item><title>Gmeek 教程</title><link>https://stayt2.github.io/post/Gmeek%20-jiao-cheng.html</link><description>&gt; [!NOTE]&#13;
&gt; Useful information that users should know, even when skimming content.&#13;
&#13;
&gt; [!TIP]&#13;
&gt; Helpful advice for doing things better or more easily.&#13;
&#13;
&gt; [!IMPORTANT]&#13;
&gt; Key information users need to know to achieve their goal.&#13;
&#13;
&gt; [!WARNING]&#13;
&gt; Urgent info that needs immediate user attention to avoid problems.&#13;
&#13;
&gt; [!CAUTION]&#13;
&gt; Advises about risks or negative outcomes of certain actions.&#13;
&#13;
# iframe&#13;
`Gmeek-html&lt;iframe width='100%' height='400px' src='https://www.youtube.com/embed/in1kpo_AWQo?si=_Kj12wzI_aVOXILo' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;' referrerpolicy='strict-origin-when-cross-origin' allowfullscreen&gt;&lt;/iframe&gt;`&#13;
&#13;
`Gmeek-html&lt;iframe style='border-radius:12px' src='https://open.spotify.com/embed/track/0U3fV7K4WFfVRgLGEAKh3g?utm_source=generator' width='100%' height='152' frameBorder='0' allowfullscreen='' allow='autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture' loading='lazy'&gt;&lt;/iframe&gt;`&#13;
。</description><guid isPermaLink="true">https://stayt2.github.io/post/Gmeek%20-jiao-cheng.html</guid><pubDate>Mon, 02 Sep 2024 07:32:46 +0000</pubDate></item><item><title>About</title><link>https://stayt2.github.io/about.html</link><description># ShortBio&#13;
- Nankai University, School of Statistics and Data Science, Data Science and Big Data Technology&#13;
- KAUST, CEMSE, Visiting Student&#13;
- HKUST, CSE, Research Assistant&#13;
- Nankai University, Cyber School, Computer Technology&#13;
- China Mobile, Mobile Research Institute, Internship&#13;
- Kwai Technology, Content and Risk Technology Department, Internship&#13;
&#13;
## Interests: &#13;
&#13;
- Machine Learning&#13;
- Machine Learning Security&#13;
- Large Language Model Security&#13;
&#13;
## Awards&#13;
- China National Scholarship, Tianjin Government Scholarship, Nankai Gong-Neng Scholarship, China National Encouragement Scholarship, Nankai Ming-Shan-Yun-Neng Scholarship&#13;
&#13;
## Collaborators&#13;
- Lijie Hu (KAUST)&#13;
- Tianhao Huang (ASU)&#13;
- Xuyao Wang (PKU)&#13;
- Yanduo Fu (NKU)&#13;
- Yihe Duan (NKU)&#13;
- Lianru Gao (NKU)&#13;
- Yingxu Huang (UESTC)&#13;
## Services:&#13;
(Sub)Reviewer for CCS2023, EMNLP 2022, TBD 2022, WASA 2022, EACL 2023&#13;
&#13;
- Teaching Assistant for Deep Learning 2024 Fall in Nankai University&#13;
- Teaching Assistant for Linear Algebra 2024 Spring in Nankai University&#13;
- Teaching Assistant for Python 2022-2024 in Nankai University&#13;
。</description><guid isPermaLink="true">https://stayt2.github.io/about.html</guid><pubDate>Mon, 02 Sep 2024 07:13:43 +0000</pubDate></item><item><title>Publications</title><link>https://stayt2.github.io/link.html</link><description>&gt; [!NOTE]&#13;
&gt; [EMNLP] Private Language Models via Truncated Laplacian Mechanism  &#13;
Tianhao Huang*, Tao Yang*, Ivan Habernal, Lijie Hu, Di Wang&#13;
The 2024 Conference on Empirical Methods in Natural Language Processing (EMNLP 2024) &#13;
&#13;
&gt; [!NOTE]&#13;
&gt; [IEEE S&amp;P] xxx&#13;
xxx&#13;
46th IEEE Symposium on Security and Privacy (IEEE S&amp;P 2025)&#13;
&#13;
。</description><guid isPermaLink="true">https://stayt2.github.io/link.html</guid><pubDate>Wed, 18 Sep 2024 11:46:17 +0000</pubDate></item></channel></rss>